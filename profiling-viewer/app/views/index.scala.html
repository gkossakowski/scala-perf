@(runs: Seq[models.BenchmarkRun], allBenchmarks: Seq[models.CompilerRevBenchmarks], scalapAvgs: Seq[Option[Double]])

@import play.api.libs.json.Json

@main("Scala compiler performance") {

<div class="hero-unit">
  <h1>Scala compiler performance</h1>
  <p>Early prototype of Scala compiler performance tracking tool.</p>
</div>

<div class="page-header">
   <h2>Latest builds <small>The last 10 benchmarks</small></h2>
</div>
<section>
   @for(run <- runs.take(10)) {
   <div class="row">
     <div class="span12">
         <p><a href="@routes.SingleCompilerRev.rev(run.rev.sha1)">@run.rev.sha1.take(7)</a> -- @run.rev.commit.getShortMessage</p>
     </div>
 </div>
}

</section>

<pre>Here are the last 10 revs:
@allBenchmarks.map(_.rev.sha1).take(10).mkString("\n")
There are @allBenchmarks.count(_.benchmarks.size > 0) out of @allBenchmarks.size revs that have benchmarks
scalapAvgs.size = @scalapAvgs.size
</pre>

<script type="text/javascript">
var sha1s = @Html(Json.toJson(allBenchmarks.map(_.rev.sha1)).toString)
var sha1Links = @Html(Json.toJson(allBenchmarks.map(compilerRevBenchmarks => routes.SingleCompilerRev.rev(compilerRevBenchmarks.rev.sha1).toString)).toString)
var sha1Messages = @Html(Json.toJson(allBenchmarks.map(_.rev.commit.getShortMessage)).toString)
var sha1Timestamps = @Html(Json.toJson(allBenchmarks.map(_.rev.commit.getCommitTime.toLong*1000)).toString)
function shortenMessage(msg, length) {
  if (msg.length > length) {
    return msg.substring(0, length-3) + '...';
  } else {
    return msg;
  }
}
$(document).ready(function() {
  var chart = new Highcharts.Chart({
    chart: {
      renderTo: 'charts-container',
      type: 'area',
      zoomType: 'x'
    },
    title: {
      text: 'scalap-src average performance'
    },
    xAxis: {
      labels: {
        formatter: function() {
          var index = this.value;
          var sha1 = sha1s[this.value];
          var timestamp = sha1Timestamps[index];
          if (typeof(sha1) === "undefined")
            return null;
          else
            return '<a href="' + sha1Links[index] + '">' + sha1.substring(0, 7) +
              '<br/>' + Highcharts.dateFormat('%b %d', timestamp) + '</a>';
        }
      }
    },
    yAxis: {
      title: {
        text: 'Average running time'
      },
      min: 3000
    },

    plotOptions: {
      series: {
        cursor: 'pointer',
        point: {
          events: {
            click: function() {
              document.location.href=sha1Links[this.category]
            }
          }
        },
      },
      area: {
        fillColor: {
          linearGradient: [0, 0, 0, 300],
          stops: [
            [0, Highcharts.getOptions().colors[0]],
            [1, 'rgba(2,0,0,0)']
          ]
        },
        lineWidth: 1,
        marker: {
          enabled: false,
          states: {
            hover: {
              enabled: true,
              radius: 5
            }
          }
        },
        shadow: false,
        states: {
          hover: {
            lineWidth: 1
          }
        }
      }
    },

    tooltip: {
      formatter: function() {
        return sha1s[this.x].substring(0,7) + ' <b>' + shortenMessage(sha1Messages[this.x], 60) + '</b><br/>' +
        Highcharts.dateFormat('%d %b %Y', sha1Timestamps[this.x]) + '<br/>' +
        Highcharts.numberFormat(this.y, 2, '.', ' ') + ' ms';
      }
    },

    series: [{
      name: 'scalap-src',
      // it's interesting to note that scala.Option is mapped to null
      data: @Html(play.api.libs.json.Json.toJson(scalapAvgs).toString)
    }]
  });
});
</script>

<div id="charts-container" style="width: 100%; height: 400px"></div>

}
